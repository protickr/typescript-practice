<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeScript Notes</title>
    <style type="text/css">
        * {
            box-sizing: border-box;
            margin: 0;
        }

        main {
            width: 900px;
            margin: 0 auto;
        }
    </style>
</head>

<body>
    <main>
        <pre>
        <h2>Fundamentals: installation, configuration</h2>
        <p>
            * install node 
            * in your project directory,
                - npm install typescript --save-dev
                - npx tsc --init
                - modify tsconfig.json 
                    {
                        "compilerOptions": {                  
                        "target": "es2016",
                        "module": "commonjs",
                        "rootDir": "./src",
                        "outDir": "./build/js",
                        "noEmitOnError": true,
                        "esModuleInterop": true,
                        "strict": true,
                        "noImplicitAny": true,
                        "strictNullChecks": true,
                        "skipLibCheck": true
                        },
                        "include": ["src"]
                    }
            
                - modify package.json 
                    scripts: 
                        dev: tsc --watch & live-server build/

        </p>

        <h2>Basic types</h2>
            * statically typed: types get checked at compile time 
            * strongly typed: every variable must have a type at compile time 
            
            * weakly/loosely typed: specifying types are not mandatory
            * dynamically typed: types are determined at runtime
            
            * type inferring: 
                TypeScript infers variable's (data) type based on the initialization value set to them, 
                but once a type is inferred the variable can not be assigned with different type of value
            
            * contextual type inferring: 
                based on the environment/context a variable is defined in, receives the appropriate type

            * basic types: string, number, boolean, any
                let firstName: string= "Protick";
                let meaningOfLife: number; 
                let isLoading: boolean; 
                let answer: any; 
                
                firstName = "John"; 
                meaningOfLife = 42; 
                isLoading = true;
            
            * function parameters type
                const sum = (a: number, b: number) => {
                return a + b;
                };
            
            * union type 
                let album: string | number; 
                let postId: string | number; 
                let isActive: number | boolean; 

            * RegExp: regular expression type
                let re: RegExp = /\w+/g; 
                console.log(typeof re);

            * Array type
                - array of string type data
                    let countries: string[] = ["Bangladesh", "India", "China"];
                
                - array of union type data (string | number | boolean)
                    let mixedElements: (string | number | boolean)[] = ["EVH", 100, true];

                    // okay
                    mixedElements = countries;
                    
                    // error: Type '(string | number | boolean)[]' is not assignable to type 'string[]'
                    countries = mixedElements;
                
            * tuple type
                let myTuple: [string, number, boolean] = ["Protick", 31, true];
        </p>

        <h2>Object Type & type alias</h2>
        <p>
            * object type
                let myObj: object;
                myObj = myTuple;
                console.log(typeof myObj);
            
            *  object type by inference
                const exampleObj = {
                    name: "Protick",
                    age: 31,
                    isWorking: true,
                };
            
            * object type annotation
            // 1.
                let person: {
                    name: string;
                    age: number;
                    isWorking: boolean;
                };
            
                person = exampleObj;
            
            * object type annotation by using type alias
            // 2.
                type Person = {
                    name: string;
                    age: number;
                    isWorking: boolean;
                    album?: (string | number)[];    // union type array
                };
            
                let protick: Person = exampleObj;
            
                const greetPerson = (person: Person) => {
                    return `Hello ${person.name}!`;
                };

                console.log(greetPerson(protick));
        </p>

        <h2>Interface</h2>
        <p>
            * object type declaration by using "interface"
                interface Person {
                    name: string;
                    age: number; 
                    isWorking: boolean;
                    album?: (string | number)[]; // union type array
                };
            
                let protick: Person = {
                    name: "Protick", 
                    age: 31, 
                    isWorking: true, 
                };
                
                const greetPerson = (person: Person) => {
                    if(person.name)
                        return `Hello ${person.name}!`;
                    return `Hello person!`;
                };
                
                console.log(greetPerson(protick));
        </p>

        <h2>Enum</h2>
        <p>
            * is not natively supported by JS but it is added to JS runtime by typescript
            utilizing some internal code transpiler?!            
                enum Grade {
                    U = 1 , 
                    D, 
                    C, 
                    B, 
                    A
                }
                console.log(Grade.U);
            * enum is enumerated and starts at position 0 unless set otherwise;
        </p>
        <h2>Type Aliases</h2>
        <p>
            type stringOrNumber = string | number;
            type stringOrNumberArray = (string | number)[];
            
            type Person = {
              name: string;
              age: number;
              isWorking: boolean;              
              album?: stringOrNumberArray; // union type array
            };
            
            type userId = stringOrNumber;
            
            * you can not set type alias to an interface
                interface userId = stringOrNumber;
            
            * type aliases can be an alias for any type
            * interfaces can only be used for classes or objects
        </p>
        <h2>Literal Types</h2>
        <p>
            * literal types
                let myName: "Dave" | "Protick" | "John";
                myName = "Protick";
            
            * literal types using type alias
                type AllowedSerials = 1 | 2 | 3;
                let userSerial: AllowedSerials;
                userSerial = 1;
        </p>

        <h2>Functions</h2>
        <p>
            * function with parameter types
                const add = (a: number, b: number): number => {
                    return a + b;
                };
                const res = add(10, 20);
                
                const logMessage = (message: any): void => {
                    console.log(message);
                };
                
                logMessage("Log this message");
                
            (types covered so far: string, number, boolean, any, enum, array, union, type alias, interface, void)
              
              
            * function type declaration 
                type mathFunction = (param1: number, param2: number) => number; 
                const sub: mathFunction = function (a, b) {
                    return a - b;
                };
              
            * function interface 
                interface mathFunc { 
                    (param1: number, param2: number): number,
                }
              
                const multiply: mathFunc = (a, b) => {
                    return a * b;
                };
              
            * optional parameter and type guard
                - your required parameters do need to come first in the parameter list

                const addAll = (a: number, b: number, c?: number): number => {
                    if (c !== undefined) {
                    return a + b + c;
                    }
                    return a + b;
                };
                
                console.log(addAll(1, 2, 3));
                
             * function parameter default value
                const sumAll = (a: number, b: number, c = 2) => {
                    return a + b + c;
                };
                console.log(sumAll(10, 20));
                
                - optional parameter can be declared in 2 ways, 
                    1. by using "?" after the parameter name 
                    2. by providing a default value for the parameter 
                    
            * rest parameter type 
                const total = (a: number, ...nums: number[]): number => {
                    return (
                    a + nums.reduce((prevTotal, currentNumber) => prevTotal + currentNumber)
                    );
                };
              
                 console.log(total(1, 2, 3, 4));
            
            * the "never" type
              - it is for functions that explicitly throws error, 
                function that explicitly throws error, its return type is inferred as "never" or if 
                    it has infinite or endless loop inside

                const createError = (errorMsg: string): never => {
                    throw new Error(errorMsg);
                };
            
            * custom type guard
                const isNumber = (value: any): boolean => {
                return typeof value === "number" ? true : false;
                };
              
            * use of the never type
                const stringOrNumber = (value: string | number): string => {
                    if (typeof value === "string") return "string";
                    if (isNumber(value)) return "number";
                    return createError("This should never happen");
                };
                console.log(stringOrNumber("10"));
                console.log(stringOrNumber(10));
        </p>

        <h2>Type Assertion</h2>
        <p>
            let x: unknown = "hello";
            let test = x as string; 

            * convert to more or less specific type
                type One = string;
                type Two = string | number;
                type Three = "hello";


                let a: One = "hello";
                let b = a as Two; // less specific
                let c = a as Three; // more specific

            * besides "as" keyword we can also use "<>" angle brackets
                - angel brackets type definition can not be used in react files .tsx
                    let d = <One>"world";
                    let e = <string | number>"world";

                let addOrConcat = (
                    a: number,
                    b: number,
                    c: "add" | "concat"
                ): number | string => {
                    if (c === "add") return a + b;
                    return "" + a + b;
                };

                let myVal: string = addOrConcat(2, 2, "concat") as string;

                - be careful! TS sees no problem - but a string is returned
                    but we are forcefully asserting it as number
                        let nextVal: number = addOrConcat(2, 3, "concat") as number;

            * specify type at left of the value with angel brackets "<>"  instead of assertion 
                and right of the variable specify data type with colon ":"

            * forced casting or double casting 
                const myRoll: string = 10 as any as string; 
                console.log(myRoll);
                

            * most useful assertion cases 
             - when you know the resultant type better than TS can guess
                const element = document.getElementById("main_canvas") as HTMLCanvasElement;

            * non null assertion 
                const myImg = document.getElementById("profile_avatar")!;

                - the exclamation sign at the end of the statement signifies that the 
                    result of that expression will not be null and we are asserting it by using the !

            
            * type assertion example
                (JavaScript)
                    const year = document.getElementById("year");
                    const thisYear = new Date().getFullYear();
                    year?.setAttribute("datetime", thisYear); 
                    year?.textContent = thisYear;

                (TypeScript)
                    const year: HTMLElement = document.getElementById("year") as HTMLSpanElement;
                    const thisYear: string = new Date().getFullYear()!.toString();
                    year.setAttribute("datetime", thisYear); 
                    year.textContent = thisYear;
        </p>
        <h2>Class</h2>
        <p>
            class Coder {
                name: string;
                music: string;
                age: number;
                lang: string;
              
                constructor(name: string, music: string, age: number, lang: string) {
                  this.name = name;
                  this.music = music;
                  this.age = age;
                  this.lang = lang;
                }
              }
              
            * using visibility modifier to remove redundancy

                class Coder {
                    // adding a property that does not have an instantiator
                    secondLang!: string;
                
                    /* 
                        protected: can be accessed in the class and also in the derived classes
                        private: can be accessed in the origin class only
                        public: can be access in the class, in derived class and via object of that class or a class
                                derived from the origin class
                    */

                    constructor(
                        public readonly name: string,
                        public music: string,
                        private age: number,
                        protected lang: string = "TypeScript"
                    ) {
                        this.name = name;
                        this.music = music;
                        this.age = age;
                        this.lang = lang;
                    }
                
                    public getAge() {
                        return this.age;
                    }
                }
                
                class WebDev extends Coder {
                    constructor(
                        public computer: string,
                        name: string,
                        music: string,
                        age: number
                    ) {
                        super(name, music, age);
                        this.computer = computer;
                    }
                
                    public getLang() {
                        return `I write ${this.lang}`;
                    }
                }
                
                const protick = new Coder("Protick Roy", "Rock", 31);
                console.log(protick.getAge());
                
                const sara = new WebDev("Mac", "Sara", "Lofi", 25);
                console.log(sara.getLang());
              /************************************************************/

            * implementing interface to a class 

                interface Musician {
                    name: string;
                    instrument: string;
                    play(action: string): string;
                }
                
                class Guitarist implements Musician {
                    constructor(public readonly name: string, public instrument: string) {
                        this.name = name;
                        this.instrument = instrument;
                    }
                
                    public play(action: string) {
                        return `${this.name} ${action} ${this.instrument}`;
                    }
                }
                
                const protick = new Guitarist("Protick Roy", "Guitar");
                console.log(protick.play("plucks"));
              
              /************************************************************/
            * static property in a class
                /* 
                    static properties and methods are not instantiated when we
                    instantiate an object of a class rather it directly belongs to the
                    class itself
                */

                class Peeps {
                    static counter: number = 0;
                    public id: number;
                
                    static getCount(): number {
                    return Peeps.counter;
                    }
                
                    constructor(public name: string) {
                    this.name = name;
                    this.id = ++Peeps.counter;
                    }
                }
                
                const john = new Peeps("John");
                const protick = new Peeps("Protick");
                const amy = new Peeps("Amy");
                
                console.log(Peeps.getCount());
                
              
            * getter setter in TypeScript 
                class Bands {
                    private dataState: string[];
                
                    constructor() {
                    this.dataState = [];
                    }
                
                    public get data(): string[] {
                    return this.dataState;
                    }
                
                    public set data(values: string[]) {
                    if (
                        Array.isArray(values) &&
                        values.every((value) => typeof value === "string")
                    ) {
                        this.dataState = values;
                        return;
                    } else {
                        throw new Error("params is not a array of string");
                    }
                    }
                }
                
                const myBands = new Bands();
                myBands.data = ["Neil Young", "Led Zep"];
                console.log(myBands.data);
        </p>
        <h2>Index signature</h2>
        <p>

            // interface without index signature 
                interface TransactionObj {
                    Pizza: number;
                    Books: number;
                    Job: number;
                }

            * index signature            
                interface TransactionObj {
                    readonly [index: string]: number;
                }
            
            * Example 2: index signature
                interface TransactionObj {
                    readonly [index: string]: number;
                    Pizza: number;
                    Books: number;
                    Job: number;
                }
                
                const todaysTransactions: TransactionObj = {
                    Pizza: -10,
                    Books: -5,
                    Job: 50,
                };
                
                console.log(todaysTransactions["Pizza"]);
                // todaysTransactions.Pizza = 30;
                
                let prop: string = "Pizza";
                console.log(todaysTransactions[prop]);
        </p>
        <h2>Keyof in type assertion</h2>
        <p>
            interface Student {
                // [index: string]: string | number | number[] | undefined,
                name: string;
                GPA: number;
                classes?: number[];
            }
                
            const student: Student = {
                name: "Protick Roy",
                GPA: 3.25,
                classes: [201, 301],
            };
            
            // option 1
            for (const key in student) {
                console.log(`${key}: ${student[key as keyof Student]}`); // keyof keyword and assertion
            }
            
            // alternatively,
            Object.keys(student).forEach((key) =>
                console.log(`${key}: ${student[key as keyof typeof student]}`)
            );

        *** what keyof does is creates a union type of string literal ***
         
        * literal types instead of an Interface

            type Streams = "salary" | "bonus" | "sidehustle";
            
            // Incomes is a type that validates a JS object which key is of type "Streams" and value of type of "number"
            
            // Record utility type
                type Incomes = Record<Streams, number | string>;
            
                const monthlyIncome: Incomes = {
                    salary: 500,
                    bonus: 100,
                    sidehustle: 200,
                };
                
                for(const key in monthlyIncome){
                    console.log(`${key}: ${monthlyIncome[key as keyof Incomes]}`);
                }
        </p>
        <h2>Generics</h2>
        <p>            
            when we do not know the type of a data beforehand, TS provides us with 
            kind of a placeholder (variable for a type) to use for function parameter, return type 
            variable, interface and type alias
            
            example 1: 
            // the problem: very specif type it is tied to data type of String
                const echoString = (arg: string): string => {};
            
            // solution: make a generic function that echos all kind of data
            // T: stands for template you can use anything here
                const echo = <T>(arg: T): T => {};
            
            // example 2:
                const isObj = <T>(arg: T): boolean => {
                    if (typeof arg == "object" && !Array.isArray(arg) && arg !== null) {
                        return true;
                    }
                    return false;
                };
                    
                console.log(isObj(true));
                console.log(isObj("this is a string"));
                console.log(isObj([1, 2, 3]));
                console.log(isObj({ a: 1, b: 2 }));
                console.log(isObj(null));            

            // example 3
                function isTrue<T>(arg: T): boolean {
                  return false;
                }
            
                const isObj = <T>(arg: T): boolean => {
                if (typeof arg == "object" && !Array.isArray(arg) && arg !== null) {
                    return true;
                }
                return false;
                };
            
                const isTrue = <T>(arg: T): { arg: T; is: boolean } => {
                    // if array and empty
                    if (Array.isArray(arg) && !arg.length) {
                        return {
                            arg,
                            is: false,
                        };
                    }
                    
                    // if object and empty
                    if (isObj(arg) && !Object.keys(arg as keyof T).length) {
                        return {
                            arg,
                            is: false,
                        };
                    }
                    
                    return {
                        arg,
                        is: !!arg,
                    };
                };

            
            * redefine the function using an interface
                interface BoolCheck<T> {
                    arg: T,
                    is: boolean,
                }
                
                const isObj = <T>(arg: T): boolean => {
                    if (typeof arg == "object" && !Array.isArray(arg) && arg !== null) {
                        return true;
                    }
                    return false;
                };
            
                const isTrue = <T>(arg: T): BoolCheck<T> => {
                    // if array and empty
                    if (Array.isArray(arg) && !arg.length) {
                        return {
                            arg,
                            is: false,
                        };
                    }
            
                // if object and empty
                if (isObj(arg) && !Object.keys(arg as keyof T).length) {
                    return {
                        arg,
                        is: false,
                    };
                }
                
                return {
                    arg,
                    is: !!arg,
                };
            };
            
            
            // example 4
                interface hasId {
                    id: number;
                }
                
                const processUser = <T extends hasId>(user: T): T => {
                    return user;
                };
                
                console.log(processUser({ id: 1, name: "Protick Roy" }));
                // console.log(processUser({ name: "Protick Roy" }));
            
            // example 5                
                interface HasId {
                    id: number;
                }
                
                const getUserProperty = <T extends HasId, K extends keyof T>(
                    users: T[],
                    key: K
                ): T[K][] => {
                    return users.map((user) => user[key]);
                }; 
            
            
            // example 6: generic in a class
                class StateObject<T> {
                    private data: T;
                    
                    constructor(value: T) {
                        this.data = value;
                    }
                    
                    public get state(): T {
                        return this.data;
                    }
                    
                    public set state(value: T) {
                        this.data = value;
                    }
                }
                
                // const store = new StateObject("Initial value"); // inference
                const store = new StateObject<string>("Initial value"); // explicit
                const numberState = new StateObject(12);
                console.log(store.state);
            
                // complex call to StateObject
                const myState = new StateObject<(number | string | boolean)[]>([
                    1,
                    "Protick Roy",
                    true,
                ]);
            
                const anotherState = new StateObject<(number | string | boolean)[]>([12]);
                console.log(anotherState.state);
        </p>
        <h2>Utility Types</h2>
        <p>
            * for common type transformations

            * partial
                interface Assignment {
                    studentId: number;
                    title: string;
                    grade: number;
                    verified?: boolean;
                }

                const updateAssignment = (
                    assignment: Assignment,
                    propsToUpdate: Partial<Assignment>
                ): Assignment => {
                    return { ...assignment, ...propsToUpdate };
                };

                const englishAssignment: Assignment = {
                    studentId: 1,
                    title: "Essay on global warming",
                    grade: 85,
                    verified: true,
                };

                const updated = updateAssignment(englishAssignment, { grade: 95 });
                console.log(updated);

            /* 
            Partial <Assignment>: requires 0 to many properties of Assignment
            Required <Assignment>: requires all properties of Assignment, even the property defined as optional in
                    Assignment interface
            */


            interface Assignment {
                studentId: number;
                title: string;
                grade: number;
                verified?: boolean; // this will be mandatory if used with Required
            }
            
            const assignGraded: Assignment = {
                studentId: 10,
                title: "Assignment on english",
                grade: 95,
            };
            
        * Required: requires all properties of an interface or type alias
            const recordAssignment = (assignment: Required<Assignment>): Assignment => {
              // send to database etc.
              return assignment;
            };
            
        * Readonly: immutable variable
            const verifiedAssignment: Readonly<Assignment> = {
              ...assignGraded,
              verified: true,
            };
            
            // verifiedAssignment.grade = 10;
            
            const recordedAssignment = recordAssignment({
              ...assignGraded,
              verified: true,
            });
            
        * Record utility type,
            // Record<ObjectKeyType, ObjectValueType>

            const hexColorMap: Record<string, string> = {
              red: "FF0000",
              green: "00FF00",
              blue: "0000FF",
            };
            
            - use of string literal in Record
                type Students = "Sara" | "Kelly";
                type LetterGrades = "A" | "B" | "C" | "D" | "U";
                
                const finalGrades: Record<Students, LetterGrades> = {
                Sara: "A",
                Kelly: "A",
                };
                
            - Record type with interface
                interface Grades {
                    assign1: number;
                    assign2: number;
                }
            
                const studentGrades: Record<Students, Grades> = {
                    Sara: { assign1: 85, assign2: 92 },
                    Kelly: { assign1: 85, assign2: 17 },
                };
            
        * Pick and Omit
            type AssignResult = Pick<Assignment, "studentId" | "grade">;
            const score: AssignResult = {
                studentId: 1,
                grade: 85,
            };
            
            type AssignPreview = Omit<Assignment, "grade" | "verified">;
            const preview: AssignPreview = {
              studentId: 1,
              title: "English assignment",
            };

            *** Required, Readonly, Record, Pick, Omit all works with interface / objects ***
            
            *** utility type: Exclude, Extract works with "string literal union types" ***

            type AdjustedGrades = Exclude<LetterGrades, "U">;
            type HighGrades = Extract<LetterGrades, "A" | "B">;
            
        * NonNullable
            type AllPossibleGrades = "Dave" | "John" | null | undefined;
            type NamesOnly = NonNullable<AllPossibleGrades>;

        * ReturnType            
            type NewAssign = { title: string; points: number };
            const createNewAssign = (title: string, points: number): NewAssign => {
                return { title, points };
            };
            
            const createNewAssign = (title: string, points: number) => {
              return { title, points };
            };
            type NewAssign = ReturnType<typeof createNewAssign>;
            
            const tsAssign: NewAssign = createNewAssign("New assignment", 100);
            
        * Parameters
            type AssignParameters = Parameters<typeof createNewAssign>;
            // AssignParameters is a tuple of [ title: string, points: number]
            
            const assignArgs: AssignParameters = ["Generics", 100];
            const tsAssign2: NewAssign = createNewAssign(...assignArgs);
            console.log(tsAssign2);
            
        * Awaited, Promise - helps us with ReturnType of a Promise
            interface User {
              id: number;
              name: string;
              username: string;
              email: string;
            }
            
            const fetchUsers = async (): Promise<User[]> => {
              const data = await fetch("https://jsonplaceholder.typicode.com/users")
                .then((res) => res.json())
                .catch((error) => console.log(error.message));
              return data;
            };
            
            type FetchUsersReturnType = Awaited<ReturnType<typeof fetchUsers>>;
            
            fetchUsers().then((users: FetchUsersReturnType) => console.log(users));
        </p>
        </pre>
    </main>
</body>